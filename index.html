<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>落ち物パズルゲーム</title>
  <style>
    body { text-align: center; font-family: Arial, sans-serif; background-color: #222; color: #fff; }
    #gameArea { position: relative; width: 300px; height: 600px; margin: 20px auto; background-color: #000; overflow: hidden; border: 2px solid #fff; }
    #score { font-size: 24px; margin-top: 10px; }
    #startButton { padding: 10px 20px; font-size: 18px; margin-top: 10px; }
    canvas { display: block; margin: 0 auto; background-color: #000; }
  </style>
</head>
<body>
  <h1>落ち物パズルゲーム</h1>
  <div id="gameArea">
    <canvas id="gameCanvas" width="300" height="600"></canvas>
  </div>
  <div id="score">スコア: 0</div>
  <button id="startButton">ゲーム開始</button>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');
    const startButton = document.getElementById('startButton');
    const scoreDisplay = document.getElementById('score');
    const blockSize = 30;
    const rows = 20;
    const cols = 10;
    let board = [];
    let currentPiece;
    let gameInterval;
    let score = 0;

    // ブロックの形状
    const pieces = [
      [[1, 1, 1, 1]], // I
      [[1, 1], [1, 1]], // O
      [[0, 1, 0], [1, 1, 1]], // T
      [[1, 0, 0], [1, 1, 1]], // L
      [[0, 0, 1], [1, 1, 1]], // J
      [[0, 1, 1], [1, 1, 0]], // S
      [[1, 1, 0], [0, 1, 1]], // Z
    ];

    // 色の設定
    const colors = ['cyan', 'yellow', 'purple', 'orange', 'blue', 'green', 'red'];

    function initBoard() {
      board = [];
      for (let r = 0; r < rows; r++) {
        board[r] = [];
        for (let c = 0; c < cols; c++) {
          board[r][c] = null;
        }
      }
    }

    function drawBoard() {
      context.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (board[r][c]) {
            context.fillStyle = board[r][c];
            context.fillRect(c * blockSize, r * blockSize, blockSize, blockSize);
            context.strokeStyle = '#000';
            context.strokeRect(c * blockSize, r * blockSize, blockSize, blockSize);
          }
        }
      }
      if (currentPiece) {
        drawPiece(currentPiece);
      }
    }

    function drawPiece(piece) {
      context.fillStyle = piece.color;
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            context.fillRect((piece.x + c) * blockSize, (piece.y + r) * blockSize, blockSize, blockSize);
            context.strokeStyle = '#000';
            context.strokeRect((piece.x + c) * blockSize, (piece.y + r) * blockSize, blockSize, blockSize);
          }
        }
      }
    }

    function createPiece() {
      const index = Math.floor(Math.random() * pieces.length);
      const shape = pieces[index];
      const color = colors[index];
      const x = Math.floor(cols / 2) - Math.floor(shape[0].length / 2);
      const y = -shape.length;
      return { shape, color, x, y };
    }

    function movePiece(dx, dy) {
      if (!collision(currentPiece.shape, currentPiece.x + dx, currentPiece.y + dy)) {
        currentPiece.x += dx;
        currentPiece.y += dy;
        drawBoard();
        return true;
      }
      return false;
    }

    function rotatePiece() {
      const rotatedShape = currentPiece.shape[0].map((val, index) =>
        currentPiece.shape.map(row => row[index]).reverse()
      );
      if (!collision(rotatedShape, currentPiece.x, currentPiece.y)) {
        currentPiece.shape = rotatedShape;
        drawBoard();
      }
    }

    function collision(shape, x, y) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const newX = x + c;
            const newY = y + r;
            if (newX < 0 || newX >= cols || newY >= rows || (newY >= 0 && board[newY][newX])) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function freezePiece() {
      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (currentPiece.shape[r][c]) {
            const x = currentPiece.x + c;
            const y = currentPiece.y + r;
            if (y >= 0) {
              board[y][x] = currentPiece.color;
            } else {
              // ゲームオーバー
              clearInterval(gameInterval);
              alert('ゲームオーバー');
              startButton.disabled = false;
              return;
            }
          }
        }
      }
      clearLines();
      currentPiece = createPiece();
    }

    function clearLines() {
      for (let r = rows - 1; r >= 0; r--) {
        if (board[r].every(cell => cell)) {
          board.splice(r, 1);
          board.unshift(Array(cols).fill(null));
          score += 10;
          scoreDisplay.textContent = 'スコア: ' + score;
          r++;
        }
      }
    }

    function gameLoop() {
      if (!movePiece(0, 1)) {
        freezePiece();
      }
      drawBoard();
    }

    function startGame() {
      initBoard();
      score = 0;
      scoreDisplay.textContent = 'スコア: 0';
      currentPiece = createPiece();
      drawBoard();
      startButton.disabled = true;
      gameInterval = setInterval(gameLoop, 500);
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        movePiece(-1, 0);
      } else if (e.key === 'ArrowRight') {
        movePiece(1, 0);
      } else if (e.key === 'ArrowDown') {
        movePiece(0, 1);
      } else if (e.key === 'ArrowUp') {
        rotatePiece();
      }
    });

    startButton.addEventListener('click', startGame);
  </script>
</body>
</html>
